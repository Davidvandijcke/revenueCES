#' let X = (PL, PM, PY)
#' let X_firm = (omega, omegal, K, eta)
#' organize variable matrics as N_f*H (for each t) (so one market, all firms in the market, next market...) (so market-level variables have all subsequent N_h entries equal)
# assign guesses of endogenous variables (take powers of two to force non-negativity constraints)
theta <- exp(gamma) # impose non-negativity/
Pih <- theta[(1:(N_f))] # Ph
Lih <- theta[((N_f+1)):(2*N_f)]
Mih <- theta[((2*N_f+1)):(3*N_f)]
# assign exogenous variables
PL <- X[1:(N_f)]
PM <- X[(N_f+1):(2*N_f)]
PY <- X[(2*N_f+1):(3*N_f)]
omega <- X_firm[1:(N_f)]
omegal <- X_firm[(N_f+1):(2*N_f)]
K <- X_firm[(2*N_f+1):(3*N_f)]
# intermediate equations
Ph <- as.matrix(unlist(lapply(unlist(lapply(seq(1,N*N_h,N), function(x) sum(Pih[x:(x+N-1)]^(1-epsi))^(1/(1-epsi)) )),
function(x) matrix(x,N,1)))) # CES sum over firm prices (need to sum over each N firms in each market first and then expand these again)
Yh <- (Ph)^(-Sigma) * PY
Yih <- (Pih / Ph)^(-epsi) * Yh # market output inverse CES share of aggregate
Y <- sum(Yh[seq(1,N*N_h,N)]^((Sigma-1)/Sigma))^(Sigma/(Sigma-1))
P <- (Yh/Y)^(1/Sigma)*Ph
#P <- (PY / Y)^(1/Sigma)
Sih <- (Pih*Yih)/(Ph*Yh) # definition market share
mu <- (epsi/(epsi-1)) / (1 - ((epsi/Sigma)-1)/(epsi-1) *  Sih) # markup
lambda <- Pih / mu # marginal cost
f <- ((1-beta_L-beta_M)*K^(sigma_CES) + beta_L*(omegal*Lih)^(sigma_CES) + beta_M * Mih^(sigma_CES))^(v/sigma_CES) # production technology
B <- PL^(sigma_CES/(sigma_CES-1)) * beta_L^(-1/(sigma_CES-1)) + PM^(sigma_CES/(sigma_CES-1)) * beta_M^(-1/(sigma_CES-1))
# set up equations
r <- matrix(NA, length(theta))
r[(1):(N_f)]  <- PL - lambda*v*(Yih/omega)^((v-sigma_CES)/sigma_CES)*(1-beta_L-beta_M)*Lih^(sigma_CES-1)*omegal^(sigma_CES)*omega # FOC cost min labor
r[(N_f+1):(2*N_f)] <- PM - lambda*v*(Yih/omega)^((v-sigma_CES)/sigma_CES)*(1-beta_L-beta_M)*Mih^(sigma_CES-1)*omega # FOC cost min materials
r[(2*N_f+1):(3*N_f)] <-   Yh - as.matrix(unlist(lapply(unlist(lapply(seq(1,N*N_h,N), function(x) sum(Yih[x:(x+N-1)]^((epsi-1)/epsi))^(epsi/(epsi-1)) )),
function(x) matrix(x,N,1))))
#r[(3*N_f+1):(4*N_f)] <- Yih - f*omega
#Yih -  f*omega
print(summary(r))
#return(error^2)
return(as.vector(r))
}
processSimData <- function(gamma, X, X_firm, t) {
theta <- exp(gamma) # impose non-negativity/
Pih <- theta[(1:(N_f))] # Ph
Lih <- theta[((N_f+1)):(2*N_f)]
Mih <- theta[((2*N_f+1)):(3*N_f)]
# assign exogenous variables
PL <- X[1:(N_f)]
PM <- X[(N_f+1):(2*N_f)]
PY <- X[(2*N_f+1):(3*N_f)]
omega <- X_firm[1:(N_f)]
omegal <- X_firm[(N_f+1):(2*N_f)]
K <- X_firm[(2*N_f+1):(3*N_f)]
# intermediate equations
Ph <- as.matrix(unlist(lapply(unlist(lapply(seq(1,N*N_h,N), function(x) sum(Pih[x:(x+N-1)]^(1-epsi))^(1/(1-epsi)) )),
function(x) matrix(x,N,1)))) # CES sum over firm prices (need to sum over each N firms in each market first and then expand these again)
Yh <- (Ph)^(-Sigma) * PY
Yih <- (Pih / Ph)^(-epsi) * Yh # market output inverse CES share of aggregate
Y <- sum(Yh[seq(1,N*N_h,N)]^((Sigma-1)/Sigma))^(Sigma/(Sigma-1))
P <- (Yh/Y)^(1/Sigma)*Ph
#P <- (PY / Y)^(1/Sigma)
Sih <- (Pih*Yih)/(Ph*Yh) # definition market share
mu <- (epsi/(epsi-1)) / (1 - ((epsi/Sigma)-1)/(epsi-1) *  Sih) # markup
df <- data.frame(period = t, Pih = Pih, Lih = Lih, Mih = Mih, PL = PL, PM = PM,
PY = PY, omega = omega, omegal = omegal, K = K, Ph = Ph, Yh = Yh,
Yih = Yih, Y = Y, P = P, mu = mu, Sih = Sih)
return(df)
}
simulation <- function(t = 40, seed = 340) {
set.seed(seed)
beta_L <<- 0.3
beta_M <<- 0.3
v <<- 1 # constant returns to scale
sigma_CES <<- 0.5 # Raval (2019)
Sigma <<- 1.1 # as in De Ridder et. al.
epsi <<- 5 # as in De Ridder et. al.
N <<- 180 # as in De Ridder et. al.
N_h <<- 8 # as in De Ridder et. al.
N_f <<- N*N_h # total number of firms
D_init <<- 1.269933e+12 / 10^10
K_init <<-  378235587 / 10^10
# assign parameters of exogenous dynamics
rho_L <- 0.67 # persistence of PL
sigma_L <- 0.06 # sd of PL
rho_M <- 0.92 # persistence of PM
sigma_M <- 0.06 # sd of PM
rho_D <- 0.86 # persistence of demand
sigma_D <- 0.68 # sd of demand
rho_o <- 0.91 # persistence of omega
sigma_o <- 0.68 # sd of omega
rho_ol <- 0.92 # persistence of omegal
sigma_ol <- 0.75 # sd of omegal
rho_K <- 0.66 # persistence of capital
sigma_K <- 0.66 # sd of capital
sigma_eta <- 0.122 # sd measurement error
# create vectors of exogenous aggregate variables
X <- exp(rbind(
repmat(simAR1(rho_L, sigma_L, rnorm(1, mean = log(1), sd = sigma_L), t, b0 = log(1)), N_f, 1), # PL
repmat(simAR1(rho_M, sigma_M, rnorm(1, mean = log(1), sd = sigma_M), t, b0 = log(1)), N_f, 1), # PM
repmat(simAR1(rho_D, sigma_D, rnorm(1, mean = log(D_init), sd = sigma_D), t, b0 = log(D_init)), N_f, 1) # PY
)) # take exponent because AR(1) process is for logs
# create vector of exogenous firm variables
# create vector of exogenous firm variables
X_firm <- exp(rbind(
simAR1(rho_o, sigma_o, rnorm(N_f, mean = log(1), sd = sigma_o), t, b0 = log(1)), # omega
simAR1(rho_ol, sigma_ol, rnorm(N_f, mean = log(1), sd = sigma_ol), t, b0 = log(1)), # omegal
simAR1(rho_K, sigma_K, rnorm(N_f, mean = log(K_init), sd = sigma_K), t, b0 =  log(K_init)), # K
))
# initialize matrix of endogenous variables
theta0 <- matrix(NA, 3*N_f) # preassign
theta0[1:(N_f)] <- rnorm(N_f, mean = log(100), sd = 0.06) # firm-level log prices
theta0[(N_f+1):(3*N_f)] <- rnorm(2*N_f, mean = log(K_init), sd = 0.1) # firm level inputs
for (step in 1:t) { # for each time period
print(paste0("PERIOD", step))
solved <- BB::BBsolve(as.vector(theta0), systemOfEqs, X = X[,step], X_firm = X_firm[,step],
control = list(maxit = 100000, noimp = 1000, tol = 1.e-7)) # solve system of non-linear equations
#solved <- pracma::fsolve(x = as.vector(theta0), f = systemOfEqs, X = X[,step], X_firm = X_firm[,step])
print(solved$message)
df_temp <-  processSimData(solved$par, X = X[,step], X_firm = X_firm[,step],
t = step)
if (step == 1) { df <- df_temp
} else { df <- rbind(df, df_temp) }
theta0 <- solved$par # use converged vector from last period as new initial vector
}
return(df)
}
systemOfEqs <- function(gamma, X, X_firm) {
#' Set up system of equations
#'
#' Takes in guess for parameter vector and spits out system of equations to be optimized
#'
#' @param theta guess for parameter vector (in this case vector of exogenous variables)
#' @param beta calibrated parameters
#' @param X exogenous variables
#' let theta = (mu, Pih, lambda, Sih, Lih, Mih, Yih, Yih_star, Yh, Ph, Y, P)
#' let beta = (beta_L, beta_M, v, sigma_CES, sigma, epsilon, N, N_h)
#' let X = (PL, PM, PY)
#' let X_firm = (omega, omegal, K, eta)
#' organize variable matrics as N_f*H (for each t) (so one market, all firms in the market, next market...) (so market-level variables have all subsequent N_h entries equal)
# assign guesses of endogenous variables (take powers of two to force non-negativity constraints)
theta <- exp(gamma) # impose non-negativity/
Pih <- theta[(1:(N_f))] # Ph
Lih <- theta[((N_f+1)):(2*N_f)]
Mih <- theta[((2*N_f+1)):(3*N_f)]
# assign exogenous variables
PL <- X[1:(N_f)]
PM <- X[(N_f+1):(2*N_f)]
PY <- X[(2*N_f+1):(3*N_f)]
omega <- X_firm[1:(N_f)]
omegal <- X_firm[(N_f+1):(2*N_f)]
K <- X_firm[(2*N_f+1):(3*N_f)]
# intermediate equations
Ph <- as.matrix(unlist(lapply(unlist(lapply(seq(1,N*N_h,N), function(x) sum(Pih[x:(x+N-1)]^(1-epsi))^(1/(1-epsi)) )),
function(x) matrix(x,N,1)))) # CES sum over firm prices (need to sum over each N firms in each market first and then expand these again)
Yh <- (Ph)^(-Sigma) * PY
Yih <- (Pih / Ph)^(-epsi) * Yh # market output inverse CES share of aggregate
Y <- sum(Yh[seq(1,N*N_h,N)]^((Sigma-1)/Sigma))^(Sigma/(Sigma-1))
P <- (Yh/Y)^(1/Sigma)*Ph
#P <- (PY / Y)^(1/Sigma)
Sih <- (Pih*Yih)/(Ph*Yh) # definition market share
mu <- (epsi/(epsi-1)) / (1 - ((epsi/Sigma)-1)/(epsi-1) *  Sih) # markup
lambda <- Pih / mu # marginal cost
f <- ((1-beta_L-beta_M)*K^(sigma_CES) + beta_L*(omegal*Lih)^(sigma_CES) + beta_M * Mih^(sigma_CES))^(v/sigma_CES) # production technology
B <- PL^(sigma_CES/(sigma_CES-1)) * beta_L^(-1/(sigma_CES-1)) + PM^(sigma_CES/(sigma_CES-1)) * beta_M^(-1/(sigma_CES-1))
# set up equations
r <- matrix(NA, length(theta))
r[(1):(N_f)]  <- PL - lambda*v*(Yih/omega)^((v-sigma_CES)/sigma_CES)*(1-beta_L-beta_M)*Lih^(sigma_CES-1)*omegal^(sigma_CES)*omega # FOC cost min labor
r[(N_f+1):(2*N_f)] <- PM - lambda*v*(Yih/omega)^((v-sigma_CES)/sigma_CES)*(1-beta_L-beta_M)*Mih^(sigma_CES-1)*omega # FOC cost min materials
r[(2*N_f+1):(3*N_f)] <-   Yh - as.matrix(unlist(lapply(unlist(lapply(seq(1,N*N_h,N), function(x) sum(Yih[x:(x+N-1)]^((epsi-1)/epsi))^(epsi/(epsi-1)) )),
function(x) matrix(x,N,1))))
#r[(3*N_f+1):(4*N_f)] <- Yih - f*omega
#Yih -  f*omega
print(summary(r))
#return(error^2)
return(as.vector(r))
}
processSimData <- function(gamma, X, X_firm, t) {
theta <- exp(gamma) # impose non-negativity/
Pih <- theta[(1:(N_f))] # Ph
Lih <- theta[((N_f+1)):(2*N_f)]
Mih <- theta[((2*N_f+1)):(3*N_f)]
# assign exogenous variables
PL <- X[1:(N_f)]
PM <- X[(N_f+1):(2*N_f)]
PY <- X[(2*N_f+1):(3*N_f)]
omega <- X_firm[1:(N_f)]
omegal <- X_firm[(N_f+1):(2*N_f)]
K <- X_firm[(2*N_f+1):(3*N_f)]
# intermediate equations
Ph <- as.matrix(unlist(lapply(unlist(lapply(seq(1,N*N_h,N), function(x) sum(Pih[x:(x+N-1)]^(1-epsi))^(1/(1-epsi)) )),
function(x) matrix(x,N,1)))) # CES sum over firm prices (need to sum over each N firms in each market first and then expand these again)
Yh <- (Ph)^(-Sigma) * PY
Yih <- (Pih / Ph)^(-epsi) * Yh # market output inverse CES share of aggregate
Y <- sum(Yh[seq(1,N*N_h,N)]^((Sigma-1)/Sigma))^(Sigma/(Sigma-1))
P <- (Yh/Y)^(1/Sigma)*Ph
#P <- (PY / Y)^(1/Sigma)
Sih <- (Pih*Yih)/(Ph*Yh) # definition market share
mu <- (epsi/(epsi-1)) / (1 - ((epsi/Sigma)-1)/(epsi-1) *  Sih) # markup
df <- data.frame(period = t, Pih = Pih, Lih = Lih, Mih = Mih, PL = PL, PM = PM,
PY = PY, omega = omega, omegal = omegal, K = K, Ph = Ph, Yh = Yh,
Yih = Yih, Y = Y, P = P, mu = mu, Sih = Sih)
return(df)
}
simdata <- simulation(t = 40, seed = 340)
sigma_0
sigma_o
simulation <- function(t = 40, seed = 340) {
set.seed(seed)
beta_L <<- 0.3
beta_M <<- 0.3
v <<- 1 # constant returns to scale
sigma_CES <<- 0.5 # Raval (2019)
Sigma <<- 1.1 # as in De Ridder et. al.
epsi <<- 5 # as in De Ridder et. al.
N <<- 180 # as in De Ridder et. al.
N_h <<- 8 # as in De Ridder et. al.
N_f <<- N*N_h # total number of firms
D_init <<- 1.269933e+12 / 10^10
K_init <<-  378235587 / 10^10
# assign parameters of exogenous dynamics
rho_L <- 0.67 # persistence of PL
sigma_L <- 0.06 # sd of PL
rho_M <- 0.92 # persistence of PM
sigma_M <- 0.06 # sd of PM
rho_D <- 0.86 # persistence of demand
sigma_D <- 0.68 # sd of demand
rho_o <- 0.91 # persistence of omega
sigma_o <- 0.68 # sd of omega
rho_ol <- 0.92 # persistence of omegal
sigma_ol <- 0.75 # sd of omegal
rho_K <- 0.66 # persistence of capital
sigma_K <- 0.66 # sd of capital
sigma_eta <- 0.122 # sd measurement error
# create vectors of exogenous aggregate variables
X <- exp(rbind(
repmat(simAR1(rho_L, sigma_L, rnorm(1, mean = log(1), sd = sigma_L), t, b0 = log(1)), N_f, 1), # PL
repmat(simAR1(rho_M, sigma_M, rnorm(1, mean = log(1), sd = sigma_M), t, b0 = log(1)), N_f, 1), # PM
repmat(simAR1(rho_D, sigma_D, rnorm(1, mean = log(D_init), sd = sigma_D), t, b0 = log(D_init)), N_f, 1) # PY
)) # take exponent because AR(1) process is for logs
# create vector of exogenous firm variables
# create vector of exogenous firm variables
X_firm <- exp(rbind(
simAR1(rho_o, sigma_o, rnorm(N_f, mean = log(1), sd = sigma_o), t, b0 = log(1)), # omega
simAR1(rho_ol, sigma_ol, rnorm(N_f, mean = log(1), sd = sigma_ol), t, b0 = log(1)), # omegal
simAR1(rho_K, sigma_K, rnorm(N_f, mean = log(K_init), sd = sigma_K), t, b0 = log(K_init)) # K
))
# initialize matrix of endogenous variables
theta0 <- matrix(NA, 3*N_f) # preassign
theta0[1:(N_f)] <- rnorm(N_f, mean = log(100), sd = 0.06) # firm-level log prices
theta0[(N_f+1):(3*N_f)] <- rnorm(2*N_f, mean = log(K_init), sd = 0.1) # firm level inputs
for (step in 1:t) { # for each time period
print(paste0("PERIOD", step))
solved <- BB::BBsolve(as.vector(theta0), systemOfEqs, X = X[,step], X_firm = X_firm[,step],
control = list(maxit = 100000, noimp = 1000, tol = 1.e-7)) # solve system of non-linear equations
#solved <- pracma::fsolve(x = as.vector(theta0), f = systemOfEqs, X = X[,step], X_firm = X_firm[,step])
print(solved$message)
df_temp <-  processSimData(solved$par, X = X[,step], X_firm = X_firm[,step],
t = step)
if (step == 1) { df <- df_temp
} else { df <- rbind(df, df_temp) }
theta0 <- solved$par # use converged vector from last period as new initial vector
}
return(df)
}
systemOfEqs <- function(gamma, X, X_firm) {
#' Set up system of equations
#'
#' Takes in guess for parameter vector and spits out system of equations to be optimized
#'
#' @param theta guess for parameter vector (in this case vector of exogenous variables)
#' @param beta calibrated parameters
#' @param X exogenous variables
#' let theta = (mu, Pih, lambda, Sih, Lih, Mih, Yih, Yih_star, Yh, Ph, Y, P)
#' let beta = (beta_L, beta_M, v, sigma_CES, sigma, epsilon, N, N_h)
#' let X = (PL, PM, PY)
#' let X_firm = (omega, omegal, K, eta)
#' organize variable matrics as N_f*H (for each t) (so one market, all firms in the market, next market...) (so market-level variables have all subsequent N_h entries equal)
# assign guesses of endogenous variables (take powers of two to force non-negativity constraints)
theta <- exp(gamma) # impose non-negativity/
Pih <- theta[(1:(N_f))] # Ph
Lih <- theta[((N_f+1)):(2*N_f)]
Mih <- theta[((2*N_f+1)):(3*N_f)]
# assign exogenous variables
PL <- X[1:(N_f)]
PM <- X[(N_f+1):(2*N_f)]
PY <- X[(2*N_f+1):(3*N_f)]
omega <- X_firm[1:(N_f)]
omegal <- X_firm[(N_f+1):(2*N_f)]
K <- X_firm[(2*N_f+1):(3*N_f)]
# intermediate equations
Ph <- as.matrix(unlist(lapply(unlist(lapply(seq(1,N*N_h,N), function(x) sum(Pih[x:(x+N-1)]^(1-epsi))^(1/(1-epsi)) )),
function(x) matrix(x,N,1)))) # CES sum over firm prices (need to sum over each N firms in each market first and then expand these again)
Yh <- (Ph)^(-Sigma) * PY
Yih <- (Pih / Ph)^(-epsi) * Yh # market output inverse CES share of aggregate
Y <- sum(Yh[seq(1,N*N_h,N)]^((Sigma-1)/Sigma))^(Sigma/(Sigma-1))
P <- (Yh/Y)^(1/Sigma)*Ph
#P <- (PY / Y)^(1/Sigma)
Sih <- (Pih*Yih)/(Ph*Yh) # definition market share
mu <- (epsi/(epsi-1)) / (1 - ((epsi/Sigma)-1)/(epsi-1) *  Sih) # markup
lambda <- Pih / mu # marginal cost
f <- ((1-beta_L-beta_M)*K^(sigma_CES) + beta_L*(omegal*Lih)^(sigma_CES) + beta_M * Mih^(sigma_CES))^(v/sigma_CES) # production technology
B <- PL^(sigma_CES/(sigma_CES-1)) * beta_L^(-1/(sigma_CES-1)) + PM^(sigma_CES/(sigma_CES-1)) * beta_M^(-1/(sigma_CES-1))
# set up equations
r <- matrix(NA, length(theta))
r[(1):(N_f)]  <- PL - lambda*v*(Yih/omega)^((v-sigma_CES)/sigma_CES)*(1-beta_L-beta_M)*Lih^(sigma_CES-1)*omegal^(sigma_CES)*omega # FOC cost min labor
r[(N_f+1):(2*N_f)] <- PM - lambda*v*(Yih/omega)^((v-sigma_CES)/sigma_CES)*(1-beta_L-beta_M)*Mih^(sigma_CES-1)*omega # FOC cost min materials
r[(2*N_f+1):(3*N_f)] <-   Yh - as.matrix(unlist(lapply(unlist(lapply(seq(1,N*N_h,N), function(x) sum(Yih[x:(x+N-1)]^((epsi-1)/epsi))^(epsi/(epsi-1)) )),
function(x) matrix(x,N,1))))
#r[(3*N_f+1):(4*N_f)] <- Yih - f*omega
#Yih -  f*omega
print(summary(r))
#return(error^2)
return(as.vector(r))
}
processSimData <- function(gamma, X, X_firm, t) {
theta <- exp(gamma) # impose non-negativity/
Pih <- theta[(1:(N_f))] # Ph
Lih <- theta[((N_f+1)):(2*N_f)]
Mih <- theta[((2*N_f+1)):(3*N_f)]
# assign exogenous variables
PL <- X[1:(N_f)]
PM <- X[(N_f+1):(2*N_f)]
PY <- X[(2*N_f+1):(3*N_f)]
omega <- X_firm[1:(N_f)]
omegal <- X_firm[(N_f+1):(2*N_f)]
K <- X_firm[(2*N_f+1):(3*N_f)]
# intermediate equations
Ph <- as.matrix(unlist(lapply(unlist(lapply(seq(1,N*N_h,N), function(x) sum(Pih[x:(x+N-1)]^(1-epsi))^(1/(1-epsi)) )),
function(x) matrix(x,N,1)))) # CES sum over firm prices (need to sum over each N firms in each market first and then expand these again)
Yh <- (Ph)^(-Sigma) * PY
Yih <- (Pih / Ph)^(-epsi) * Yh # market output inverse CES share of aggregate
Y <- sum(Yh[seq(1,N*N_h,N)]^((Sigma-1)/Sigma))^(Sigma/(Sigma-1))
P <- (Yh/Y)^(1/Sigma)*Ph
#P <- (PY / Y)^(1/Sigma)
Sih <- (Pih*Yih)/(Ph*Yh) # definition market share
mu <- (epsi/(epsi-1)) / (1 - ((epsi/Sigma)-1)/(epsi-1) *  Sih) # markup
df <- data.frame(period = t, Pih = Pih, Lih = Lih, Mih = Mih, PL = PL, PM = PM,
PY = PY, omega = omega, omegal = omegal, K = K, Ph = Ph, Yh = Yh,
Yih = Yih, Y = Y, P = P, mu = mu, Sih = Sih)
return(df)
}
simdata <- simulation(t = 40, seed = 340)
simulation <- function(t = 40, seed = 340) {
set.seed(seed)
beta_L <<- 0.3
beta_M <<- 0.3
v <<- 1 # constant returns to scale
sigma_CES <<- 0.5 # Raval (2019)
Sigma <<- 1.1 # as in De Ridder et. al.
epsi <<- 5 # as in De Ridder et. al.
N <<- 180 # as in De Ridder et. al.
N_h <<- 8 # as in De Ridder et. al.
N_f <<- N*N_h # total number of firms
D_init <<- 1.269933e+12 / 10^10
K_init <<-  378235587 / 10^10
# assign parameters of exogenous dynamics
rho_L <- 0.67 # persistence of PL
sigma_L <- 0.06 # sd of PL
rho_M <- 0.92 # persistence of PM
sigma_M <- 0.06 # sd of PM
rho_D <- 0.86 # persistence of demand
sigma_D <- 0.68 # sd of demand
rho_o <- 0.91 # persistence of omega
sigma_o <- 0.68 # sd of omega
rho_ol <- 0.92 # persistence of omegal
sigma_ol <- 0.75 # sd of omegal
rho_K <- 0.66 # persistence of capital
sigma_K <- 0.66 # sd of capital
sigma_eta <- 0.122 # sd measurement error
# create vectors of exogenous aggregate variables
X <- exp(rbind(
repmat(simAR1(rho_L, sigma_L, rnorm(1, mean = log(1), sd = sigma_L), t, b0 = log(1)), N_f, 1), # PL
repmat(simAR1(rho_M, sigma_M, rnorm(1, mean = log(1), sd = sigma_M), t, b0 = log(1)), N_f, 1), # PM
repmat(simAR1(rho_D, sigma_D, rnorm(1, mean = log(D_init), sd = sigma_D), t, b0 = log(D_init)), N_f, 1) # PY
)) # take exponent because AR(1) process is for logs
# create vector of exogenous firm variables
# create vector of exogenous firm variables
X_firm <- exp(rbind(
simAR1(rho_o, sigma_o, rnorm(N_f, mean = log(1), sd = sigma_o), t, b0 = log(1)), # omega
simAR1(rho_ol, sigma_ol, rnorm(N_f, mean = log(1), sd = sigma_ol), t, b0 = log(1)), # omegal
simAR1(rho_K, sigma_K, rnorm(N_f, mean = log(K_init), sd = sigma_K), t, b0 = log(K_init)) # K
))
# initialize matrix of endogenous variables
theta0 <- matrix(NA, 3*N_f) # preassign
theta0[1:(N_f)] <- rnorm(N_f, mean = log(100), sd = 0.06) # firm-level log prices
theta0[(N_f+1):(3*N_f)] <- rnorm(2*N_f, mean = log(K_init), sd = 0.1) # firm level inputs
for (step in 1:t) { # for each time period
print(paste0("PERIOD", step))
solved <- BB::BBsolve(as.vector(theta0), systemOfEqs, X = X[,step], X_firm = X_firm[,step],
control = list(maxit = 100000, noimp = 1000, tol = 1.e-7)) # solve system of non-linear equations
#solved <- pracma::fsolve(x = as.vector(theta0), f = systemOfEqs, X = X[,step], X_firm = X_firm[,step])
print(solved$message)
df_temp <-  processSimData(solved$par, X = X[,step], X_firm = X_firm[,step],
t = step)
if (step == 1) { df <- df_temp
} else { df <- rbind(df, df_temp) }
theta0 <- solved$par # use converged vector from last period as new initial vector
}
return(df)
}
systemOfEqs <- function(gamma, X, X_firm) {
#' Set up system of equations
#'
#' Takes in guess for parameter vector and spits out system of equations to be optimized
#'
#' @param theta guess for parameter vector (in this case vector of exogenous variables)
#' @param beta calibrated parameters
#' @param X exogenous variables
#' let theta = (mu, Pih, lambda, Sih, Lih, Mih, Yih, Yih_star, Yh, Ph, Y, P)
#' let beta = (beta_L, beta_M, v, sigma_CES, sigma, epsilon, N, N_h)
#' let X = (PL, PM, PY)
#' let X_firm = (omega, omegal, K, eta)
#' organize variable matrics as N_f*H (for each t) (so one market, all firms in the market, next market...) (so market-level variables have all subsequent N_h entries equal)
# assign guesses of endogenous variables (take powers of two to force non-negativity constraints)
theta <- exp(gamma) # impose non-negativity/
Pih <- theta[(1:(N_f))] # Ph
Lih <- theta[((N_f+1)):(2*N_f)]
Mih <- theta[((2*N_f+1)):(3*N_f)]
# assign exogenous variables
PL <- X[1:(N_f)]
PM <- X[(N_f+1):(2*N_f)]
PY <- X[(2*N_f+1):(3*N_f)]
omega <- X_firm[1:(N_f)]
omegal <- X_firm[(N_f+1):(2*N_f)]
K <- X_firm[(2*N_f+1):(3*N_f)]
# intermediate equations
Ph <- as.matrix(unlist(lapply(unlist(lapply(seq(1,N*N_h,N), function(x) sum(Pih[x:(x+N-1)]^(1-epsi))^(1/(1-epsi)) )),
function(x) matrix(x,N,1)))) # CES sum over firm prices (need to sum over each N firms in each market first and then expand these again)
Yh <- (Ph)^(-Sigma) * PY
Yih <- (Pih / Ph)^(-epsi) * Yh # market output inverse CES share of aggregate
Y <- sum(Yh[seq(1,N*N_h,N)]^((Sigma-1)/Sigma))^(Sigma/(Sigma-1))
P <- (Yh/Y)^(1/Sigma)*Ph
#P <- (PY / Y)^(1/Sigma)
Sih <- (Pih*Yih)/(Ph*Yh) # definition market share
mu <- (epsi/(epsi-1)) / (1 - ((epsi/Sigma)-1)/(epsi-1) *  Sih) # markup
lambda <- Pih / mu # marginal cost
f <- ((1-beta_L-beta_M)*K^(sigma_CES) + beta_L*(omegal*Lih)^(sigma_CES) + beta_M * Mih^(sigma_CES))^(v/sigma_CES) # production technology
B <- PL^(sigma_CES/(sigma_CES-1)) * beta_L^(-1/(sigma_CES-1)) + PM^(sigma_CES/(sigma_CES-1)) * beta_M^(-1/(sigma_CES-1))
# set up equations
r <- matrix(NA, length(theta))
r[(1):(N_f)]  <- PL - lambda*v*(Yih/omega)^((v-sigma_CES)/sigma_CES)*(1-beta_L-beta_M)*Lih^(sigma_CES-1)*omegal^(sigma_CES)*omega # FOC cost min labor
r[(N_f+1):(2*N_f)] <- PM - lambda*v*(Yih/omega)^((v-sigma_CES)/sigma_CES)*(1-beta_L-beta_M)*Mih^(sigma_CES-1)*omega # FOC cost min materials
r[(2*N_f+1):(3*N_f)] <-   Yh - as.matrix(unlist(lapply(unlist(lapply(seq(1,N*N_h,N), function(x) sum(Yih[x:(x+N-1)]^((epsi-1)/epsi))^(epsi/(epsi-1)) )),
function(x) matrix(x,N,1))))
#r[(3*N_f+1):(4*N_f)] <- Yih - f*omega
#Yih -  f*omega
#print(summary(r))
#return(error^2)
return(as.vector(r))
}
processSimData <- function(gamma, X, X_firm, t) {
theta <- exp(gamma) # impose non-negativity/
Pih <- theta[(1:(N_f))] # Ph
Lih <- theta[((N_f+1)):(2*N_f)]
Mih <- theta[((2*N_f+1)):(3*N_f)]
# assign exogenous variables
PL <- X[1:(N_f)]
PM <- X[(N_f+1):(2*N_f)]
PY <- X[(2*N_f+1):(3*N_f)]
omega <- X_firm[1:(N_f)]
omegal <- X_firm[(N_f+1):(2*N_f)]
K <- X_firm[(2*N_f+1):(3*N_f)]
# intermediate equations
Ph <- as.matrix(unlist(lapply(unlist(lapply(seq(1,N*N_h,N), function(x) sum(Pih[x:(x+N-1)]^(1-epsi))^(1/(1-epsi)) )),
function(x) matrix(x,N,1)))) # CES sum over firm prices (need to sum over each N firms in each market first and then expand these again)
Yh <- (Ph)^(-Sigma) * PY
Yih <- (Pih / Ph)^(-epsi) * Yh # market output inverse CES share of aggregate
Y <- sum(Yh[seq(1,N*N_h,N)]^((Sigma-1)/Sigma))^(Sigma/(Sigma-1))
P <- (Yh/Y)^(1/Sigma)*Ph
#P <- (PY / Y)^(1/Sigma)
Sih <- (Pih*Yih)/(Ph*Yh) # definition market share
mu <- (epsi/(epsi-1)) / (1 - ((epsi/Sigma)-1)/(epsi-1) *  Sih) # markup
df <- data.frame(period = t, Pih = Pih, Lih = Lih, Mih = Mih, PL = PL, PM = PM,
PY = PY, omega = omega, omegal = omegal, K = K, Ph = Ph, Yh = Yh,
Yih = Yih, Y = Y, P = P, mu = mu, Sih = Sih)
return(df)
}
simdata <- simulation(t = 40, seed = 340)
library(revenueCES)
?use_data
K <- system.file("extdata", "orbis_sim_sample.csv", packages = "readr")
head(K)
K
library(revenueCES)
K <- system.file("extdata", "orbis_sim_sample.csv", packages = "readr")
K
K <- system.file("extdata", "orbis_sim_sample.csv", packages = "revenueCES")
K
library(revenueCES)
K <- system.file("extdata", "orbis_sim_sample.csv", packages = "revenueCES")
K
fread('orbis_sim_sample.csv')
read.table('orbis_sim_sample.csv')
library(devtools)
K <- system.file("extdata", "orbis_sim_sample.csv", packages = "revenueCES")
K
library(revenueCES)
library(revenueCES)
# create vectors of exogenous aggregate variables
X <- exp(rbind(
repmat(simAR1(rho_L, sigma_L, rnorm(1, mean = log(1), sd = sigma_L), t, b0 = log(1)), N_f, 1), # PL
repmat(simAR1(rho_M, sigma_M, rnorm(1, mean = log(1), sd = sigma_M), t, b0 = log(1)), N_f, 1), # PM
repmat(simAR1(rho_D, sigma_D, rnorm(1, mean = log(D_init), sd = sigma_D), t, b0 = log(D_init)), N_f, 1) # PY
)) # take exponent because AR(1) process is for logs
K <- system.file("extdata", "orbis_sim_sample.csv", packages = "revenueCES")
K
library(revenueCES)
K <- system.file("extdata", "orbis_sim_sample.csv", packages = "revenueCES")
L
K
read.table(file = '"orbis_sim_sample.csv"')
read.table(file = "orbis_sim_sample.csv")
library(devtools)
